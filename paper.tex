\documentclass{llncs}

\usepackage{url,xspace,amssymb}

\newcommand{\OpenTheory}{OpenTheory\xspace}
\newcommand{\theory}[2]{{#1}\,\triangleright\,{#2}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}

\begin{document}

\title{Standalone Tactics using OpenTheory}

\author{Ramana Kumar\thanks{supported by the Gates Cambridge Trust}\inst{1}\and Joe Hurd\inst{2}}

\institute{University of Cambridge, \email{Ramana.Kumar@cl.cam.ac.uk}\and Galois, Inc., \email{joe@gilith.com}}

\maketitle

\begin{abstract}
Proof tools in interactive theorem provers are usually developed within and tied to a specific system, which leads to a duplication of effort to make the functionality available in different systems.
Many verification projects would benefit from access to proof tools developed in other systems.
Using \OpenTheory as a language for communicating between systems, we show how to turn a proof tool implemented for one system into a standalone tactic available to many systems via the web.
This enables, for example, LCF-style proof reconstruction efforts to be shared by users of different interactive theorem provers and removes the need for each user to install the external tool being integrated.
\end{abstract}

\section{Introduction}

There are many LCF-style systems for interactively developing machine-checked formal theories, including HOL4~\cite{slind08brief}, HOL Light~\cite{DBLP:conf/tphol/Harrison09a}, ProofPower~\cite{ProofPower}, and Isabelle/HOL~\cite{wenzel08isabelle}.
The logic implemented by these systems is essentially the same, but the collections of theory libraries and proof tools built on top of the logical kernels differ.
Where similar proof tools exist in multiple systems it is usually the result of duplicated effort.

Examples of duplicated effort on tactics include the integration of external tools into HOL-based provers.
For instance, Kumar and Weber~\cite{DBLP:conf/itp/KumarW11} and Kun\v{c}ar~\cite{DBLP:conf/itp/Kuncar11} give independent integrations of a quantified boolean formula solver into HOL4 and HOL Light.
Weber and Amjad~\cite{weber09efficiently} give high-performance integrations of SAT solvers into three HOL-based systems; each integration requires a separate implementation.
Sledgehammer~\cite{DBLP:conf/frocos/BlanchetteBN11} is only available for Isabelle/HOL, but would be useful if available for other provers.

Besides duplicate initial effort, costs of maintenance can be multiplied over different provers, and improvements in functionality can become restricted to a single prover unnecessarily.
For instance, the Metis first-order prover~\cite{hurd2003d} is integrated in at least three HOL-based provers, but the HOL4 version is very old compared to the latest version in Isabelle/HOL.
Slind's TFL package for defining recursive functions~\cite{slindphd}, originally implemented for both Isabelle/HOL and HOL4, was superseded in Isabelle/HOL by Krauss's function definition package~\cite{DBLP:journals/jar/Krauss10}.
The improvements of Krauss's method over TFL ought to be applicable to other HOL-based provers, but a direct reimplementation would require substantial effort.

It makes sense to speak of similar proof tools in different interactive theorem provers not just because they implement essentially the same logic, but also because there is a shared base of concepts: booleans, inductive datatypes, recursive functions, natural numbers, lists, sets, etc.
The \OpenTheory standard library~\cite{hurd2011} formalises this shared base as a collection of theory packages containing proofs written in the simple \emph{article} format designed for storing and sharing higher order logic theories~\cite{hurd2009}.
We use \OpenTheory as a language for interactive theorem provers to communicate with proof tools on a remote server, and thereby obtain the following two benefits:
\begin{enumerate}
\item\textbf{Proof Articles:} A standard format to encode the goals that will be sent to the proof tools and the proofs that will be received.

\item\textbf{Standard Library:} An extensible way to fix the meaning of constants and type definitions between systems.
\end{enumerate}

We contend that proof tools for interactive theorem provers need only be written and maintained in one place rather than once per system, using \emph{standalone tactics} that are available online and communicate using \OpenTheory.
An added advantage when the tactic is an integration of an external tool is that a user of the interactive theorem prover need not install the external tool: it only needs to be available on the server hosting the standalone tactic.

The contributions of this rough diamond are:
\begin{enumerate}
\item A general method for turning existing proof tools implemented in interactive theorem provers into standalone tactics~(\secref{implementation}).

\item Preliminary results profiling the performance of working examples of standalone tactics~(\secref{performance}).
\end{enumerate}

\section{Lifting Proof Tools into the Cloud}
\label{sec:implementation}

\subsection{\OpenTheory for Tactic Communication}

An example: the user of an interactive theorem prover faced with the goal
\[
\forall n.\ 8\le n\Rightarrow\exists s,t.\ n = 3s + 5t
\]
decides to pass it off to a standalone tactic for linear arithmetic.

The input for the standalone tactic is the goal, and the output is a proof of the theorem.
Standalone tactics use the \OpenTheory article format for communicating terms and proofs.
The interactive theorem prover serializes the goal term from its local internal format to an article file, and sends the article over the web to the standalone tactic.
If successful, the standalone tactic sends back another article file encoding a proof of the goal, which the interactive theorem prover replays through its logical kernel to create the desired theorem.

This example illustrates the key requirements for an interactive theorem prover to use standalone tactics:
\begin{enumerate}
\item\label{req:artr} Ability to replay proofs by reading \OpenTheory articles.

\item\label{req:artw} Ability to write terms as \OpenTheory articles.

\item\label{req:comm} Ability to communicate over the web with external programs.
\end{enumerate}

Requirements~\ref{req:artr} and \ref{req:artw} can be satisfied for an interactive theorem prover by implementing an \OpenTheory interface that can interpret and construct articles.
The central concept in \OpenTheory is that of a \emph{theory package}, $\theory{\Gamma}{\Delta}$, which proves that the set of theorems $\Delta$ logically derive from the set of assumptions $\Gamma$.
An article is a concrete representation of a theory package, consisting of instructions for a virtual machine whose operations include construction of types and terms, and the primitive inference rules of higher order logic.
To \emph{read} an article, an interactive theorem prover performs the primitive inferences and other instructions listed in the file.
The \OpenTheory logical kernel is based on HOL Light's logical kernel, and the instructions are chosen to make it easy to read articles into any system that can prove theorems of higher order logic.

An article file represents a theory $\theory{\Gamma}{\Delta}$.
By taking $\Delta$ to be the set of theorems proved by a proof tool and $\Gamma$ to be the set of theorems used by the proof tool, we can view the result of executing a proof tool as a logical theory.
In our example above of using a linear arithmetic standalone tactic on the given goal, this theory might be
\[
\theory{\left\{\begin{array}{l}
\vdash\forall n.\ n + 0 = n \\
\vdash\forall m,n.\ m + n = n + m \\
\cdots
\end{array}\right\}}
{\bigl\{\vdash\forall n.\ 8\le n\Rightarrow\exists s,t.\ n = 3s + 5t\bigr\}}
\]
where the assumptions consist of a collection of standard arithmetic facts.

% Furthermore, we can represent a higher-order logic term in a theory by including the term in the statement of a theorem.\footnote{For example, we could represent $t$ by the theory $\emptyset\rhd\{\vdash{t=t}\}$.
% (The article format allows for multiple occurrences of $t$ to be shared.)
% This kind of encoding is necessary to represent terms of non-boolean type, since the conclusion of a theorem must be boolean.}
% Thus the same format, article files, can be used to encode terms and proofs for communication with tactics.
% Additional (non-logical) data can always be communicated separately.

The main benefit of using \OpenTheory for communication is that it provides a standard, independent framework for fixing the meanings of constants between different systems.
For example, the numerals $3$, $5$ and $8$ in the example goal term can be encoded in binary using the standard constants \texttt{Number.Natural.bit0} and \texttt{Number.Natural.bit1}.
The full names and properties of these constants are indicated in the \OpenTheory standard library, and interactive theorem provers can maintain translations to and from their local names and theorems.
A system using a different encoding for numbers (say unary, with \texttt{Number.Natural.suc} and \texttt{Number.Natural.zero}) could use additional standalone tactics to translate between encodings.

Implementing an \OpenTheory interface to satisfy Requirements~\ref{req:artr} and~\ref{req:artw} above carries the additional benefit of giving the interactive theorem prover access to all theories stored as \OpenTheory packages, not just those that are the output of standalone tactics.

\subsection{Extracting Tactics from Interactive Theorem Provers}

There are two approaches to obtaining a standalone tactic: either write one directly; or extract an existing tactic from an interactive theorem prover.
We have experimented with the second approach, extracting tactics from HOL4 and from HOL Light.
The procedure is reasonably lightweight, but less flexible than writing a standalone tactic directly.
For tactic extraction to succeed, the key requirements of the interactive theorem prover are:
\begin{enumerate}
\item\label{req:io} Ability to read and write \OpenTheory article files.

\item\label{req:log} Ability to record proofs and present them over the \OpenTheory kernel.

\item\label{req:ckpt} Ability to make a standalone executable encompassing the tactic functionality without the usual interface to the interactive theorem prover.
\end{enumerate}

Just as the requirements of an interactive theorem prover to use standalone tactics also enable it to import \OpenTheory packages in general, the first two requirements to create standalone tactics also enable a system to create and export \OpenTheory packages.
(The last requirement enables running on a server.)

Requirement~\ref{req:log} poses the highest barrier: a standalone tactic must record each proof at a level of detail sufficient to prove the same theorem using the \OpenTheory kernel.
It helps if the system containing the tactic uses the LCF architecture, that is, theorems can only be created by a small number of primitive inference rules, as is the case for HOL4 and HOL Light.

We met Requirement~\ref{req:log} by augmenting the internal theorem type with a type of proofs, to track primitive inferences used.
Then we expressed each primitive inference as a derived rule above the \OpenTheory kernel.
In many cases, there is a direct counterpart (\eg reflexivity of equality is primitive in all three kernels).
But, for example, HOL4's primitive rule for definition by specification must be emulated in \OpenTheory, for example by using Hilbert choice.
Although Isabelle/HOL uses the LCF architecture, its logical kernel is quite different from \OpenTheory; we therefore expect translating Isabelle/HOL proofs to be more difficult than HOL4 and HOL Light proofs.

To satisfy Requirement~\ref{req:ckpt} in HOL4, we used the `export' facility of the PolyML compiler, which creates a standalone executable that runs an ML function.
For each tactic, we captured a function that reads an article representing the input term, runs the tactic (recording the proof), and writes an article containing the proof.
The situation for HOL Light is more complicated because OCaml does not provide such an `export' facility, and a HOL Light session typically starts by proving the standard library.
We used a general-purpose checkpointing facility to capture a HOL Light session at the point where it is ready to read an article and run a tactic.

% <mention the need in some cases to filter articles through the opentheory tool? maybe do this in the performance section. the reasons include: to remove prover-specific (Unwanted.id) tags, and to canonicalise HOL Light's constant names (using the interpret: as: package lines). Overall, these details are probably unimportant... but affect the performance>

\section{Preliminary Performance Results}
\label{sec:performance}

\begin{table}
\begin{center}
\begin{tabular}{||@{~}l@{~}||@{}l@{~}r@{~}|@{~}r@{~}l@{}||@{~}r@{~}||@{}l@{~}r@{~}|@{~}r@{~}l@{}||@{~}r@{~}||r@{~}||}
\hline
\textbf{Problem} & & \multicolumn{2}{c}{\textbf{Goal}} & & \textbf{Web} & & \multicolumn{2}{c}{\textbf{Proof}} & & \textbf{Total} & \textbf{Local} \\
\cline{2-4} \cline{7-9}
\textbf{Name} & & \textbf{Size} & \textbf{Time} & & \textbf{Time} & & \textbf{Size} & \textbf{Time} & & \textbf{Time} & \textbf{Time} \\
 & & \textbf{(b)} & \textbf{(s)} & & \textbf{(s)} & & \textbf{(b)} & \textbf{(s)} & & \textbf{(s)} & \textbf{(s)} \\
\hline
QBF${}_1$ & & 927 & 0.001 & & 1.064 & & 10,991 & 0.022 & & 1.088 & 0.002\\
QBF${}_2$ & & 1,474 & 0.001 & & 1.892 & & 79,944 & 0.139 & & 2.034 & 0.024\\
QBF${}_3$ & & 1,546 & 0.001 & & 1.821 & & 91,639 & 0.172 & & 1.996 & 0.024\\
SKICo${}_1$ & & 927 & 0.001 & & 1.212 & & 20,047 & 0.041 & & 1.255 & 0.000\\
SKICo${}_2$ & & 1,474 & 0.002 & & 1.557 & & 52,249 & 0.113 & & 1.673 & 0.001\\
SKICo${}_3$ & & 1,546 & 0.002 & & 1.716 & & 60,642 & 0.125 & & 1.844 & 0.005\\
\hline
\end{tabular}
\end{center}
\caption{Performance profiling for the test standalone tactics.}
\label{tab:performance}
\end{table}

We collected preliminary performance data for two tactics extracted from HOL4, made standalone, and called in HOL Light.
They are QBF~\cite{DBLP:conf/itp/KumarW11}, which proves quantified boolean formulas, and SKICo, which rewrites terms to combinatory form, for example proving $\vdash(\forall{x}.\ x\lor\lnot x)=(\forall)\ (\mathtt{S}\ (\lor)\ (\lnot))$.
We used the following three test goals:
\begin{enumerate}
\item $\forall x.\ x \lor\lnot x$

\item $\exists p.\ (\forall q.\ p \lor\lnot q) \land\forall q.\ \exists r.\ r$

\item $\exists x.\ \forall y.\ \exists z.\ (\lnot x \lor\lnot y) \land (\lnot z\lor\lnot y)$
\end{enumerate}
For each invocation of a standalone tactic on a test goal, Table~\ref{tab:performance} profiles the time and space requirements of three phases of execution: encoding the goal as an article; communicating and executing the standalone tactic via the web; and replaying the proof article received.
For comparison, the time to run the tactic locally within HOL4 is given in the rightmost column.

The sizes of the articles for the test goals and the resulting proofs are comparable to the typical size of web requests and the resulting pages, so we can be confident that we are within the normal operating range of the web tools we use (\texttt{curl} on the client and CGI scripts on the server).
For problems involving larger articles (long proofs or big goals) we may wish to compress them using \texttt{gzip} before sending them to the client---previous experiments showed a 90\% compression ratio is typical on articles~\cite{hurd2009}.

Turning now to execution time, the bulk of the time is spent executing the standalone tactic on the web and communicating, so there is not much to be gained from optimizing the client.
``Web Time'' includes reading the goal article, running the proof tool, writing the proof article, and network communication.
Using \texttt{traceroute} we see a 0.173s network delay between the test client in Portland, OR, USA and the test server in Cambridge, UK, which accounts for at least 0.346s of delay.
The overall time is in the 1--2s range, which is very slow for workaday tactics but may well be tolerated by the user to gain access to the functionality of a proof tool on another system.

% Speed comparisons against using built-in tactics.
% <compare builtin holqbf, holqbf with builtin minisat, and holqbf with external minisat (i.e. chain of two webtactics) on a simple and difficult qbf problem>

% <How does (or would we expect) performance to scale with size of terms and proofs involved? Encoding/decoding terms/proofs presumably scales linearly.>

% Amount of code and time required, compared to porting tactics at the implementation level.

\section{Related Work}

An impressive example of providing reasoning infrastructure over the web is System on TPTP~\cite{DBLP:conf/lpar/Sutcliffe10}.
Here, multiple automatic theorem provers can be called on a problem (\eg satisfiability of a formula, or whether a goal follows from assumptions) expressed in the standard TPTP format.
The usual scenario is a decision problem in first-order logic, but TPTP includes support for higher-order terms (THF format) and for expressing proofs in a standard language (TSTP).

The idea of separate reasoning tools communicating to enhance a proof development environment is also being pursued in the Evidential Tool Bus~\cite{DBLP:conf/icfem/Rushby05} and the MathServe System~\cite{DBLP:conf/cade/ZimmerA06}.
This idea is a natural extension of the integration of automatic tools with interactive theorem provers.

\section{Conclusion}

We have shown how, using \OpenTheory for communication, we can write tools for higher order logic reasoning tasks as standalone tactics, making them available to multiple interactive theorem provers and independently maintainable.
Existing proof tools can be extracted from their home systems for reuse.
There is a substantial but hopefully tolerable overhead of communicating goals and proofs in article files over the web.

\bibliographystyle{splncs}
\bibliography{paper}

\end{document}
