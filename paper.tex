\documentclass{llncs}

\usepackage{url,xspace,amssymb}

\newcommand{\OpenTheory}{OpenTheory\xspace}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\ie}{i.e.\xspace}

\begin{document}

\title{Standalone Tactics using OpenTheory}

\author{Ramana Kumar\thanks{supported by the Gates Cambridge Trust}\inst{1}\and Joe Hurd\inst{2}}

\institute{\email{Ramana.Kumar@cl.cam.ac.uk}\and\email{joe@galois.com}}

\maketitle

\begin{abstract}
Tactics, \ie functions that compute low-level inferences to achieve a high-level reasoning goal, are usually developed within and tied to a particular proof assistant, which leads to code duplication across different systems and inhibits reuse.
Projects spanning multiple proof assistants would benefit from interoperability and from access to the union of all implemented tactics.
Using the OpenTheory proof exchange format, we show how to turn a tactic implemented for one system into one available to many via the web.
This enables, for example, LCF-style proof reconstruction efforts for fast automatic provers to be shared by users of multiple proof assistants and removes the need for each user to install the automatic prover.
\end{abstract}

\section{Introduction}
There are many similar LFC-style systems for interactively developing machine-checked formal theories, including HOL4~\cite{slind08brief}, HOL Light~\cite{DBLP:conf/tphol/Harrison09a}, ProofPower~\cite{ProofPower}, and Isabelle/HOL~\cite{wenzel08isabelle}.
The logic implemented by these systems is essentially the same, but the collections of libraries and tactics built atop the logical kernels differ.
Where similar functionality exists in two systems it is usually the result of duplicate effort.

It makes sense to speak of similar functionality in different systems not just because they use roughly the same logic, but also because there is a shared base of concepts: booleans, inductive datatypes, recursive functions, natural numbers, lists, sets, etc.  
The \OpenTheory standard library~\cite{DBLP:conf/nfm/Hurd11} formalises this shared base, using \OpenTheory~\cite{hurd2009}, a format designed for storing and sharing higher-order logic theories.
We use \OpenTheory to communicate with tactics (sending goals and receiving proofs), and thereby obtain
\begin{enumerate}
\item
a standard format (\OpenTheory article files) for goals and proofs, and
\item
an extensible way to fix the meaning of constants and type definitions.
\end{enumerate}

Examples of duplicated effort on tactics include the integration of external tools into HOL-based provers.
For instance, Kumar and Weber~\cite{DBLP:conf/itp/KumarW11} and Kun\v{c}ar~\cite{DBLP:conf/itp/Kuncar11} give independent integrations of a quantified boolean formula solver into a higher-order logic based system (HOL4 in one case and HOL Light in the other).
Weber and Amjad~\cite{weber09efficiently} give high-performance integrations of SAT solvers into three HOL-based systems (HOL4, HOL Light, and Isabelle/HOL); each integration requires a separate implementation.
Sledgehammer~\cite{DBLP:journals/japll/MengP09,Paulson_threeyears,DBLP:conf/frocos/BlanchetteBN11} is only available for Isabelle/HOL, but would be useful if available for other provers.

Besides duplicate initial effort, costs of maintenance can be multiplied over different provers, and improvements in functionality can become restricted to a single prover unnecessarily.
For instance, Hurd's first-order prover, Metis~\cite{DBLP:conf/cade/Hurd02}, is integrated in at least three HOL-based provers, but the HOL4 version is very old compared to the latest version in Isabelle/HOL.
Another example is a package for defining recursive functions, TFL~\cite{slindphd}, originally implemented for both Isabelle/HOL and HOL4, but recently superceded in Isabelle/HOL only by Krauss's function definition package~\cite{DBLP:journals/jar/Krauss10}.
The improvements of Krauss's method over TFL ought to be applicable to other HOL-based provers, but a direct re-implementation would require substantial effort.

We contend that tactics or libraries for proof assistants need only be written and maintained in one place rather than once per system. 
An added advantage when the tactic is an integration of an external tool is that a user of the proof assistant need not also have installed the external tool, because a standalone tactic can be accessed from a web server where the tool is installed.

The contributions of this rough diamond are:
\begin{itemize}
\item
a method (\secref{implementation}) for making existing libraries standalone, using the \OpenTheory article format, including working examples online; and,
\item
preliminary performance data (\secref{performance}) comparing standalone tactics against direct implementations.
\end{itemize}

\section{Making Existing Tactics into Web Services}
\label{sec:implementation}

\subsection{\OpenTheory for Tactic Communication}
As an example, consider proving $\vdash20+(12\times x)<(x\times 8)-13$.
The user of a proof assistant needs to prove this theorem, and decides to pass it off to a standalone tactic for linear arithmetic.
The input for the tactic is the term $20+(12\times x)<(x\times 8)-13$, and the output is a proof of the theorem.
Standalone tactics use \OpenTheory article files for communicating both terms and theorems.
The proof assistant translates the term from its local internal format to \OpenTheory article format, and sends the resulting article over the web to the tactic.
The tactic returns another article, encoding a proof, which the proof assistant replays to create the desired theorem.

The example illustrates the key requirements of the proof assistant: the ability to
\begin{enumerate}
\item \label{req:artr} replay proofs by reading \OpenTheory articles,
\item \label{req:artw} write terms as \OpenTheory articles, and,
\item \label{req:comm} communicate, for example over the web, with external programs.
\end{enumerate}

Items~\ref{req:artr} and \ref{req:artw} require implementation work for interpreting and constructing articles.
The central concept in \OpenTheory is that of a \emph{theory package}, $\Gamma\rhd\Delta$, which proves that the set of theorems $\Delta$ logically derive from the set of assumptions $\Gamma$.
An \emph{article file} is the basic unit\footnote{Composite theory packages are also possible.} for constructing theory packages.
It consists of instructions for a virtual machine whose operations include primitive inference rules of higher-order logic and basic term-manipulation.

The instructions allowed in an article file represent the \OpenTheory \emph{logical kernel}.
To read an article, a proof assistant performs the inferences and other instructions listed in the file.
The \OpenTheory kernel is very close to HOL Light's kernel.
It should be easy to read articles in any system that can prove theorems of higher-order logic.

An article file represents a theory $\Gamma\rhd\Delta$.
By taking $\Delta$ to be the theorems proved by a tactic and $\Gamma$ to be any theorems the tactic uses, we can view the result of applying a tactic as a theory.
In our example above, we have $\Delta=\{\vdash20+(12\times x)<(x\times 8)-13\}$ and might have $\Gamma\ni\forall{m\,n}.\;m\times n = n\times m$ amongst other assumptions.
Furthermore, we can represent a higher-order logic term in a theory by including the term in the statement of a theorem. \footnote{For example, we could represent $t$ by the theory $\{\vdash\mathtt{K\;F\;}t\}\rhd\{\vdash\mathtt{K\;F\;}t\}$, where $\mathtt{K}:\alpha\to\beta\to\alpha$ is the combinator defined by $\mathtt{K}\;x\;y=x$, and $\mathtt{F}$ is falsity (any boolean would do).
This kind of encoding is necessary to represent terms of non-boolean type, since the conclusion of a theorem must be boolean.}
Thus the same format, article files, can be used to encode terms and proofs for communication with tactics.
Additional (non-logical) data can always be communicated separately.

The main advantage to using \OpenTheory for communication is that it provides a standard, independent framework for fixing the meanings of constants between different systems.
For example, the term $20+(12\times x)<(x\times 8)-13$ might involve applications of constants \texttt{Number.Numeral.zero} and \texttt{Number.Numeral.bit1}, encoding the numbers in binary format.
The names and namespaces of these constants are indicated in the \OpenTheory standard library, and proof assistants can maintain translations to and from their local names.
A system using a different encoding for numbers (say unary, with \texttt{Number.Natural.suc}) could use additional standalone tactics to translate between encodings.
<...?>

Requirements~\ref{req:artr} and \ref{req:artw} above carry the additional benefit of giving a proof assistant access to traditional \OpenTheory packages (\ie not just the output of standalone tactics).

\subsection{Isolating tactics from their home systems}
There are two approaches to obtaining a standalone tactic: either write one directly, or extract an existing tactic from a proof assistant. 
We have experimented with the second approach, taking tactics from HOL4 and from HOL Light.
The procedure is reasonably lightweight, but less flexible than writing a standalone tactic directly.
The key requirements of the proof assistant are:
\begin{enumerate}
\item
\label{req:io} an \OpenTheory article file reader and writer,
\item
\label{req:log} a facility for recording proofs and converting them to the \OpenTheory logical kernel, and,
\item
\label{req:ckpt} a facility for checkpointing the proof assistant, or for extracting a standalone executable encompassing the tactic functionality.
\end{enumerate}
<first two items are the most work, but have the additional benefit of allowing import/export of theories in opentheory repositories, as mentioned above. so: to use standalone tactics you also get to use opentheory packages, but if you can make yourself into a standalone tactic you can also export opentheory packages.>
<in HOL4 and HOL Light, item 2 is accomplished by augmenting the internal theorem type with a type of proofs, to track primitive inferences used. this step is made easy by LCF architecture: could be very difficult in systems that don't already generate proofs somehow, or with significantly different kernel (cf isabelle)>
<either use Polyml.export or checkpointing to capture a function that reads a goal article, runs the tactic (recording the proof), and writes the proof article back>

<Implementation details to put on the web: simple cgi>

\section{Preliminary Performance Results}
\label{sec:performance}

Speed comparisons against using built-in tactics.
<compare builtin holqbf, holqbf with builtin minisat, and holqbf with external minisat (i.e. chain of two webtactics) on a simple and difficult qbf problem>

Amount of code and time required, compared to porting tactics at the implementation level.

\section{Related Work}

System on TPTP~\cite{DBLP:conf/lpar/Sutcliffe10}.
<Comparison to THF?>
Evidential tool bus~\cite{DBLP:conf/icfem/Rushby05,fk:etb}.
Omega.
Natural extension of the integration of automatic tools into interactive systems.

\section{Conclusions}

Highly customised tactics for a particular proof system might suffer performance hits if the factorisation through the OpenTheory kernel cannot be done efficiently.
By the same token, the article format might admit optimisation by restructuring low-level proofs, and such optimisers could be widely applied.

Other examples of functionality that could usefully be made prover-independent include packages for defining recursive datatypes or for solving classes of arithmetic problems.

<extensions to other logics?>

\bibliographystyle{splncs}
\bibliography{paper}

\end{document}
